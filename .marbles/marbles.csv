id,title,description,status,priority,requestor,assignee,closed_by,created_at,updated_at,blocks,blocked_by
m-36ea,Remove unused method: short() from diff.rs,Method is used in output.rs:940. DO NOT REMOVE.,closed,1,rushmode,rushmode,rushmode,2025-12-29T06:36:52.011Z,2025-12-29T06:38:21.992Z,,
m-099b,Remove unused method: symbols_by_type() from index.rs,Unused method at ./src/index.rs:196,closed,1,rushmode,rushmode,Pi,2025-12-29T06:36:56.403Z,2025-12-30T03:06:01.667Z,,
m-1f13,Remove unused test functions from test_files/,"Test files (example.c, sample.py, test.py) contain unused functions intentionally for parsing test coverage. These are sample data files, not actual tests.",closed,1,rushmode,rushmode,rushmode,2025-12-29T06:37:00.160Z,2025-12-29T06:38:04.130Z,,
m-5ae4,Remove dead functions from git.rs,"Removed list_files_at_commit() and get_commit_info() - never called, superseded by get_changed_files() and integrated logic",closed,1,rushmode,rushmode,rushmode,2025-12-29T06:45:22.883Z,2025-12-29T06:45:24.650Z,,
m-bb68,cm trace fails despite direct caller relationship,"cm callers cmd_query returns main, but cm trace main cmd_query fails. BFS misses Rust match arm calls. Core feature broken.",closed,0,opus,opus,opus,2025-12-29T07:36:50.129Z,2025-12-29T07:48:22.345Z,,
m-860c,cm query should default to fuzzy matching,Exact match default is counter-intuitive. Help says 'always use --fuzzy' but it's not the default. Invert to --exact flag.,closed,0,opus,opus,opus,2025-12-29T07:36:50.165Z,2025-12-29T07:48:22.345Z,,
m-5695,cm query needs --limit flag,100+ results blow agent context window. Add --limit N to cap output. High priority for token efficiency.,closed,0,opus,opus,opus,2025-12-29T07:36:50.198Z,2025-12-29T07:48:22.345Z,,
m-66a8,cm untested floods with markdown noise,Returns 200+ headings/code blocks from .md files. Real untested code buried. Add --code-only or exclude markdown by default.,closed,1,opus,opus,opus,2025-12-29T07:36:50.231Z,2025-12-29T14:43:59.751Z,,
m-cbd3,cm diff needs file-level filtering,ALREADY WORKS: cm diff HEAD~3 src/main.rs filters correctly. Path parameter exists and is implemented. Close this as invalid - feature already exists.,closed,1,opus,opus,opus,2025-12-29T07:36:50.263Z,2025-12-29T14:45:29.765Z,,
m-ac44,cm callers/callees silent on nonexistent symbols,Returns 'No calls found' for both missing symbols AND symbols with no calls. Should distinguish: 'Symbol not found' vs 'No callers'.,closed,1,opus,opus,Pi,2025-12-29T07:36:50.293Z,2025-12-30T03:06:01.667Z,,
m-c8a2,Invalid flag values silently fallback,--format badformat warns but continues. --context invalid is silent. Both should error with valid options list.,closed,1,opus,opus,opus,2025-12-29T07:37:05.391Z,2025-12-29T14:48:45.570Z,,
m-884a,cm snapshot/compare noisy with doc changes,snapshot compare uses serialized symbols in src/snapshot.rs (SnapshotSymbol list) and diffs in src/diff.rs; markdown parser adds headings/code_blocks so doc/codeblock churn increases noise. consider filter flag like --code-only or symbol-type allowlist.,open,2,opus,opus,,2025-12-29T07:37:05.430Z,2026-01-11T01:32:11.148Z,,
m-a173,cm implements returns self-impls mixed with trait impls,"ALREADY WORKS: --trait-only flag exists and filters inherent impls. 'cm implements Parser' shows 3 (including impl Parser), 'cm implements Parser --trait-only' shows 2 (only trait impls). Feature complete.",closed,2,opus,opus,opus,2025-12-29T07:37:05.463Z,2025-12-29T14:58:07.329Z,,
m-0ab9,Add --format json for structured output,output formats live in src/output.rs (OutputFormat: Default/Human/AI). no json variant yet; adding  likely touches src/main.rs clap arg + OutputFormatter.* dispatch.,open,2,opus,opus,,2025-12-29T07:37:05.497Z,2026-01-11T01:32:11.118Z,,
m-6cc6,cm test-deps confusing output for tests without imports,"test-deps command is documented in src/main.rs, output likely in src/output.rs; when a test has no imports, messaging should say 'no external imports' vs 'no production symbols'.",open,2,opus,opus,,2025-12-29T07:37:05.527Z,2026-01-11T01:32:11.133Z,,
m-8871,Fast mode activation unclear,fast mode auto-enable lives in src/main.rs (around line ~2088): let use_fast_mode = !search_all && (fast || file_count >= 1000); (search_all disables fast). could surface this via stats output or a new flag like show-cache-info.,open,2,opus,opus,,2025-12-29T07:37:05.558Z,2026-01-11T01:32:39.383Z,,
m-643c,cm query flag order confusing,Tried 'cm query find_untested --exact' but got error. Flag must come BEFORE symbol name. Natural to put flags after positional args. Consider: allow flags in any position OR improve error message to suggest correct placement.,closed,2,opus,opus,opus,2025-12-29T14:45:06.673Z,2025-12-29T14:51:28.929Z,,
m-2e7a,cm callers/callees need --limit flag,cm query has --limit flag but callers/callees don't. These commands can also return huge output. Add --limit N flag to cap results for token efficiency.,closed,1,opus,opus,Pi,2025-12-29T14:45:11.573Z,2025-12-30T03:06:01.667Z,,
m-7fa8,cm query fails on Rust enum variants and command names,"rust indexing currently captures only enum_item names, not enum variants. see src/parser/rust.rs: process_enums query for enum_item name. clap subcommands are often enum variants (e.g. Command::Implements), so Found 11 symbols

## IMPLEMENTS - FIND ALL IMPLEMENTATIONS
- Type: heading
- File: ./ANNALS/HELP_REWRITE.md
- Lines: 477-478
- Signature: h3 (###)

## ImplementsKind
- Type: enum (exported)
- File: ./src/implements.rs
- Lines: 10-15

## cmd_implements
- Type: function
- File: ./src/main.rs
- Lines: 3112-3158
- Signature: (
    interface: String,
    path: PathBuf,
    fuzzy: bool,
    extensions: String,
    no_cache: bool,
    rebuild_cache: bool,
    trait_only: bool,
    format: OutputFormat,
)

## format_implements
- Type: method (exported)
- File: ./src/output.rs
- Lines: 2276-2282
- Signature: (&self, implementations: &[Implementation], interface: &str)

## test_ts_implements
- Type: function
- File: ./src/implements.rs
- Lines: 441-450
- Signature: ()

## impl ImplementsKind
- Type: class
- File: ./src/implements.rs
- Lines: 17-26

## test_java_implements
- Type: function
- File: ./src/implements.rs
- Lines: 453-461
- Signature: ()

## format_implements_ai
- Type: method
- File: ./src/output.rs
- Lines: 2355-2376
- Signature: (&self, implementations: &[Implementation], interface: &str)

## format_implements_human
- Type: method
- File: ./src/output.rs
- Lines: 2312-2353
- Signature: (
        &self,
        implementations: &[Implementation],
        interface: &str,
    )

## format_implements_default
- Type: method
- File: ./src/output.rs
- Lines: 2284-2310
- Signature: (
        &self,
        implementations: &[Implementation],
        interface: &str,
    )

## 9. `cm implements` – Returns All Impls, Not Just Trait Implementations
- Type: heading
- File: ./ANNALS/friction-points.md
- Lines: 270-271
- Signature: h2 (##) finds funcs/heads but not the variant itself.",closed,2,opus,opus,Pi,2025-12-29T14:57:48.331Z,2026-01-11T03:24:57.864Z,,m-8f1e
m-0fbd,Fix false negative in 'cm callers': Rust method calls not detected,fix rust callers: update src/callgraph.rs extract_rust_calls tree-sitter query to also capture method_call_expression (receiver.method()) in addition to call_expression/field_expression/scoped_identifier/macro_invocation. repro: callers symbols_by_type returns 0 but deps used-by finds 54.,closed,0,Pi,Pi,Pi,2025-12-30T02:38:14.208Z,2026-01-11T01:56:09.193Z,m-e569|m-533a,
m-94df,cm query: --exact flag not accepted (clap arg missing?),"running  errors with 'unexpected argument --exact'. main.rs defines an exact flag for query, so binary and clap config are out of sync or arg declared incorrectly.",closed,1,Pi,Pi,Pi,2025-12-30T02:42:34.138Z,2025-12-30T03:06:01.667Z,,
m-2e72,"callers/callees/query: documented flags (--limit, --exact) are rejected by clap",dogfooding:  and  error 'unexpected argument --limit'. also  rejected. help text + main.rs struct suggest these should exist; binary/clap config likely diverged.,closed,0,Pi,Pi,Pi,2025-12-30T02:45:24.820Z,2025-12-30T03:06:01.667Z,,
m-caf3,deps used-by is more reliable than callers rn; mismatch between text search and AST callgraph,"confirmed mismatch: callers uses AST call extraction in src/callgraph.rs (extract_calls_from_source → extract_rust_calls) while deps used-by is text-based and finds 54 usages for symbols_by_type. until callers handles rust method_call_expression, deps used-by is more reliable.",closed,1,Pi,Pi,Pi,2025-12-30T02:45:27.833Z,2026-01-11T01:55:44.712Z,,
m-fabe,Verify P0 and P1 issues are real by dogfooding cm,,closed,1,Pi,Pi,Pi,2025-12-30T03:02:42.872Z,2025-12-30T03:04:27.647Z,,
m-50d6,--help,"dogfood: CodeMapper (cm) - Code Analysis at LLM Speed

Analyze codebases instantly by mapping symbols (functions, classes, methods)
using tree-sitter AST parsing. Everything runs in-memory, no databases.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TYPICAL WORKFLOWS

1. EXPLORING UNKNOWN CODE
   Step 1: cm stats .
   → Size and composition (how big? what languages?)
   
   Step 2: cm map . --level 2 --format ai
   → File structure (where's the logic?)
   
   Step 3: cm query <symbol>
   → Find code (where exactly?)
   
   Step 4: cm inspect ./path/to/file
   → Deep dive (what's in this module?)

2. FINDING A BUG (you know the symptom, need the source)
   Step 1: cm query <suspected_function> --show-body
   → See the implementation
   
   Step 2: cm callers <function>
   → Who calls this? (Is it called from where the bug manifests?)
   
   Step 3: cm trace <entry_point> <suspected_function>
   → Trace the call path (how does the bug get triggered?)
   
   Step 4: cm tests <function>
   → Find tests (are there existing tests for this?)

3. BEFORE REFACTORING
   Step 1: cm callers <function>
   → Understand impact (who depends on this?)
   
   Step 2: cm callees <function>
   → What does it depend on? (what breaks if we change this?)
   
   Step 3: cm tests <function>
   → Run tests (verify nothing breaks)
   
   Step 4: cm since main --breaking
   → (After refactor) Did we break anything vs main?

4. UNDERSTANDING AN API
   Step 1: cm entrypoints .
   → What's exported? (what's the public surface?)
   
   Step 2: cm implements <interface>
   → Find all implementations (how many ways is this used?)
   
   Step 3: cm schema <DataClass>
   → See field structure (what does the data look like?)

5. VALIDATING CODE HEALTH
   Step 1: cm untested .
   → Find uncovered symbols (what's not tested?)
   
   Step 2: cm since <last_release> --breaking
   → Did we break anything? (breaking changes since release?)
   
   Step 3: cm since <last_release>
   → Full changelog (what changed?)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COMMANDS (organized by task)

[DISCOVERY - Start here]
  stats        → Project size and composition (functions, classes, imports)
  map          → File listing with symbol counts (3 detail levels)
  query        → Find symbols by name (main search tool)
  inspect      → List all symbols in one file
  deps         → Track imports and usage

[CALL GRAPH - Understand code flow]
  callers      → WHO calls this function? (reverse dependencies)
  callees      → What DOES this function call? (forward dependencies)
  trace        → CALL PATH from A → B (shortest route)
  entrypoints  → Public APIs with no internal callers (dead code?)
  tests        → Which tests call this symbol?
  test-deps    → What production code does a test touch?

[GIT HISTORY - Blame and timeline]
  diff         → Symbol-level changes vs a commit (what changed?)
  since        → Breaking changes since commit (what broke?)
  blame        → Who last touched this symbol? (when, commit, author)
  history      → Full evolution of a symbol (all commits touching it)

[TYPE ANALYSIS - Understand data flow]
  types        → Parameter types and return type (where are they defined?)
  implements   → Find all implementations of an interface
  schema       → Field structure (structs, classes, dataclasses)

[SNAPSHOTS - Compare over time]
  snapshot     → Save current state (named checkpoint)
  compare      → Diff current vs saved snapshot (what changed?)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

KEY FACTS

OUTPUT FORMATS:
  --format default  → Markdown (documentation, readable)
  --format human    → Tables (terminal viewing, pretty)
  --format ai       → Compact (LLM context, token-efficient) ← RECOMMENDED

PERFORMANCE:
  Small repos (< 100 files)    → < 20ms instant
  Medium repos (100-1000)      → Cached, ~0.5s load
  Large repos (1000+)          → Fast mode auto-enabled (10-100x speedup)
  Incremental rebuilds         → 45-55x faster than full reindex

CACHING:
  Auto-enabled on projects ≥ 300ms to parse
  Small projects never create cache (no .codemapper/ clutter)
  Subsequent runs load from cache (~0.5s)
  File changes auto-detected (you don't manage cache)
  Flags: --no-cache (skip), --rebuild-cache (force rebuild)

SEARCH MODES:
  Exact   → cm query MyClass           (case-sensitive, precise)
  Fuzzy   → cm query myclass          (DEFAULT: case-insensitive, flexible)
  Exact   → cm query myclass --exact  (strict matching)

LANGUAGES SUPPORTED:
  ✓ Python       → Functions, classes, methods, imports
  ✓ JavaScript   → Functions, classes, methods, imports
  ✓ TypeScript   → Functions, classes, methods, interfaces, types, enums
  ✓ Rust         → Functions, structs, impl blocks, traits, enums
  ✓ Java         → Classes, interfaces, methods, enums, javadoc
  ✓ Go           → Functions, structs, methods, interfaces
  ✓ C            → Functions, structs, includes
  ✓ Markdown     → Headings, code blocks

GIT REQUIREMENTS:
  diff      → Must be in a git repo
  since     → Must be in a git repo
  blame     → Must be in a git repo
  history   → Must be in a git repo
  (Other commands work anywhere)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COMMON FLAGS

--exact              → Strict matching (default is fuzzy)
--format <format>    → Output style: default (markdown), human (tables), ai (compact)
--show-body          → Include actual code (not just signatures)
--exports-only       → Public symbols only (functions with export, pub, etc.)
--full               → Include anonymous/lambda functions (normally hidden)
--context minimal    → Signatures only (default, fast)
--context full       → Include docstrings and metadata
--no-cache           → Skip cache, always reindex (troubleshooting)
--rebuild-cache      → Force cache rebuild
--extensions py,rs   → Comma-separated file types to include

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TROUBLESHOOTING

NO SYMBOLS FOUND?
  ✓ Fuzzy matching by default (matches more)
  ✓ Check --extensions py,js,ts (default: py,js,ts,jsx,tsx,rs,java,go,c,h,md)
  ✓ Verify file encoding is UTF-8
  ✓ Run: cm stats . (to see what's indexed)

SLOW QUERIES?
  ✓ Large repo (1000+ files)? Fast mode auto-enables (use --fast explicitly)
  ✓ First run builds cache (~10s), cache hits ~0.5s after
  ✓ Try --no-cache if cache is stale (rare)

GIT COMMANDS FAIL?
  ✓ Must be in a git repository (diff, since, blame, history need git)
  ✓ Commit must exist (HEAD~1, abc123, main, v1.0 all work)
  ✓ File must have git history (blame, history)

OUTPUT TOO VERBOSE?
  ✓ Use --format ai (most compact, LLM-optimized)
  ✓ Use --format human (pretty tables for terminal)
  ✓ Use --context minimal (signatures only)

NO TEST COVERAGE?
  ✓ Run: cm untested .
  ✓ Test detection by file pattern (_test.rs, test_*.py, *.test.js, etc.)
  ✓ Test detection by naming convention (test*, Test*, #[test], @Test, etc.)

EXAMPLES:
  # Get the lay of the land
  cm stats .                           # Project overview
  cm map . --level 2 --format ai       # File structure
  
  # Find and explore
  cm query authenticate                # Search (fuzzy by default)
  cm inspect ./src/auth.py             # Deep dive
  cm query Parser --show-body          # See implementation
  
  # Understand flow
  cm callers process_payment           # Who calls it?
  cm callees process_payment           # What does it call?
  cm trace main process_payment        # Call path
  
  # Before refactoring
  cm callers my_function               # Impact radius
  cm tests my_function                 # Verify coverage exists
  
  # Git analysis
  cm diff main                         # Changes vs main
  cm since v1.0 --breaking             # Breaking changes since v1.0
  cm blame authenticate ./auth.py      # Who last touched it?
  
  # Type analysis
  cm types process_payment             # What types flow through?
  cm schema Order                      # Field structure
  cm implements Iterator               # Find all implementations
  
  # Health check
  cm untested .                        # What's not tested?
  cm entrypoints .                     # Public API surface

For detailed help on any command: cm <command> --help


Usage: cm [OPTIONS] <COMMAND>

Commands:
  stats        Display statistics: file counts, symbol breakdown, and parse performance
  map          Generate a map showing project organization at different detail levels (1-3)
  query        Search for functions, classes, and methods across your codebase
  inspect      Analyze one file and list all functions, classes, and methods it contains
  deps         Analyze import relationships and symbol usage across the codebase
  index        Test that files can be indexed correctly (reports file count and timing)
  diff         Show symbol-level changes between current code and a git commit
  callers      Find all places where a function/method is called
  callees      Find all functions/methods that a symbol calls
  tests        Find test functions that call a given symbol
  untested     Find functions and methods that are not called by any test
  since        Show breaking API changes since a git commit (removed symbols, signature changes)
  entrypoints  Find entrypoints: exported symbols that are not called internally
  trace        Show the shortest call path from symbol A to symbol B
  test-deps    List production (non-test) symbols called by a test file
  blame        Show who last modified a symbol and when
  history      Show the evolution of a symbol across git history
  implements   Find all classes/structs that implement a given interface or trait
  types        Analyze types used in a symbol's signature and locate their definitions
  schema       Display field schema for data structures (structs, classes, dataclasses, etc.)
  snapshot     Save a snapshot of current codebase symbols for later comparison
  compare      Show symbol-level changes between current code and a saved snapshot
  help         Print this message or the help of the given subcommand(s)

Options:
  -f, --format <FORMAT>  Output format: 'default' (markdown), 'human' (tables), 'ai' (token-efficient) [default: default]
  -h, --help             Print help prints long rich help (257 lines) from src/main.rs clap about=. if issue was missing/incorrect help, seems resolved; if it meant subcommand-specific help, specify which cmd.",closed,1,Pi,Pi,Pi,2025-12-30T03:22:34.997Z,2026-01-11T03:11:26.241Z,,
m-c7bb,cm callers floods with results for common method names,"callers currently matches only extracted callee name string; no type/receiver disambiguation. logic in src/callgraph.rs find_callers + extract_*_calls; needs class/struct-aware resolution, or at least accept qualified method syntax (Type::method / Type.method) and filter by receiver type.",open,2,Pi,Pi,,2025-12-30T03:22:48.147Z,2026-01-11T01:32:43.775Z,,
m-df5c,m-2e72 is FALSE POSITIVE: documented flags work correctly,tested --limit and --exact flags with cm query and cm callers - both work. help text is correct. issue description outdated.,closed,3,Pi,Pi,Pi,2025-12-30T03:22:55.537Z,2026-01-11T01:32:11.195Z,,
m-ceb6,cross-check src/ vs ready marbles issues,map each ready issue to concrete src modules/lines; add pointers + close false positives,closed,1,Pi,Pi,Pi,2026-01-11T01:30:27.115Z,2026-01-11T01:32:50.120Z,,
m-969c,fix rust callers + add cm impact,(1) fix rust call extraction to include method_call_expression so callers/tests/trace work reliably; (2) add new  command that summarizes signature + callers + tests + maybe untested for a symbol in one shot,closed,0,Pi,reddot,Pi,2026-01-11T01:46:15.875Z,2026-01-11T01:46:58.528Z,,
m-e569,p0: rust callers handles method_call_expression,extend src/callgraph.rs extract_rust_calls query to capture method_call_expression (and maybe related nodes) so ✗ No callers found for 'symbols_by_type' matches actual method calls,closed,0,Pi,Pi,Pi,2026-01-11T01:46:40.068Z,2026-01-11T01:56:19.728Z,m-533a,m-0fbd
m-533a,p1: add cm impact command (symbol-centered quick breakage report),"new subcommand impact that outputs: symbol definition/signature (from query), callers (count+locations), tests touching it, and optional untested status; optimized for tight edit loop",closed,0,Pi,Pi,Pi,2026-01-11T01:46:43.980Z,2026-01-11T01:57:02.192Z,,
m-a5d8,implement cm impact,add new subcommand impact that outputs symbol summary + callers + tests + untested status in one run,closed,0,Pi,Pi,Pi,2026-01-11T01:56:58.635Z,2026-01-11T02:00:09.081Z,,
m-776d,dogfood ux pass: callers+impact (llm-first polish),"run cm commands against repo + sample inputs; note ux footguns, output noise, missing flags; file followup marbles; update ANNALS/20260110-fixes.md with findings",closed,1,Pi,Pi,Pi,2026-01-11T02:05:19.552Z,2026-01-11T02:09:55.637Z,,
m-0fb9,ux: impact should support --limit (forwarded to callers),"dogfood: impact has no limit flag; calling 'cm impact X --limit 5' errors. since impact can print huge callers/tests lists, add a limit flag (applies to both) or separate callers/tests limits.",closed,2,Pi,Pi,Pi,2026-01-11T02:06:50.065Z,2026-01-11T02:41:53.175Z,,m-57f7
m-ec6f,ux: impact should avoid always printing full callers/tests,"dogfood: impact always prints full callers + tests sections. for LLM-first, default should probably show counts + top N lines; add a flag (e.g. full) to print everything.",closed,2,Pi,Pi,Pi,2026-01-11T02:07:07.077Z,2026-01-11T02:41:53.175Z,,m-57f7
m-d39b,ux: release binary prints build warnings into command output,"dogfood: cargo-run shows dead_code warnings (callgraph.rs EntrypointCategory::as_str, EntrypointInfo::is_exported, find_callees_by_name). for LLM-first, these warnings pollute stdout/stderr; fix dead_code or gate unused code behind cfg(test)/feature.",closed,2,Pi,Pi,Pi,2026-01-11T02:07:51.432Z,2026-01-11T02:41:53.175Z,,m-57f7
m-c983,ux: impact should ignore non-callable symbol types (headings/code blocks),"dogfood: impact can match markdown headings (e.g. README 'Output Formats') and then reports callers/tests=0, which reads like a code symbol. impact should filter to code symbol types by default (function/method/class/enum/etc), or require an explicit flag to include docs.",closed,2,Pi,Pi,Pi,2026-01-11T02:08:02.741Z,2026-01-11T02:41:53.175Z,,m-57f7
m-5670,ux: impact should disambiguate fuzzy matches + avoid self-recursive callers,"dogfood: impact with fuzzy match picks first result silently; for 'format' it picked format_map, and callers list included internal/self calls (format_map calling format_map_*). using exact match reduces noise. suggestion: show candidate matches when fuzzy, and hide self-calls by default (or group them).",closed,2,Pi,Pi,Pi,2026-01-11T02:09:11.814Z,2026-01-11T02:41:53.175Z,,m-57f7
m-57f7,p0: polish cm impact output + flags,"implement: impact defaults (top-n), add limit, filter to code symbols, reduce warning noise. (notes: already filed sub-issues m-0fb9/m-ec6f/m-c983/m-5670/m-d39b; tackle them under this umbrella.)",closed,0,Pi,Pi,Pi,2026-01-11T02:29:25.972Z,2026-01-11T02:41:53.167Z,m-0fb9|m-ec6f|m-c983|m-5670|m-d39b|m-494e|m-be59,m-e870
m-494e,"implement: impact defaults (top-n), add limit, filter to code symbols, reduce warning noise","work m-57f7: improve impact UX defaults, add --limit, avoid docs/headings by default, show disambiguation list for fuzzy, suppress self-calls; fix rust dead_code warnings",closed,0,Pi,Pi,Pi,2026-01-11T02:32:09.868Z,2026-01-11T02:32:18.805Z,,m-57f7
m-e870,p0: cm impact ux polish,"implement m-57f7: impact defaults to top-n, supports --limit, filters docs by default, shows disambiguation list for fuzzy matches, and reduces rustc warning noise",closed,0,Pi,Pi,Pi,2026-01-11T02:36:52.082Z,2026-01-11T02:36:58.863Z,m-57f7,
m-be59,implement m-57f7 (impact ux polish + warning cleanup),add impact limit/top-n defaults + code-symbol filtering + fuzzy disambiguation; remove dead_code warnings in callgraph,closed,0,Pi,Pi,Pi,2026-01-11T02:38:33.846Z,2026-01-11T02:42:12.214Z,,m-57f7
m-7c2a,dx: add short help mode (-h) and keep long help (--help),"make CodeMapper (cm) - Code Analysis at LLM Speed

Analyze codebases instantly by mapping symbols (functions, classes, methods)
using tree-sitter AST parsing. Everything runs in-memory, no databases.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TYPICAL WORKFLOWS

1. EXPLORING UNKNOWN CODE
   Step 1: cm stats .
   → Size and composition (how big? what languages?)
   
   Step 2: cm map . --level 2 --format ai
   → File structure (where's the logic?)
   
   Step 3: cm query <symbol>
   → Find code (where exactly?)
   
   Step 4: cm inspect ./path/to/file
   → Deep dive (what's in this module?)

2. FINDING A BUG (you know the symptom, need the source)
   Step 1: cm query <suspected_function> --show-body
   → See the implementation
   
   Step 2: cm callers <function>
   → Who calls this? (Is it called from where the bug manifests?)
   
   Step 3: cm trace <entry_point> <suspected_function>
   → Trace the call path (how does the bug get triggered?)
   
   Step 4: cm tests <function>
   → Find tests (are there existing tests for this?)

3. BEFORE REFACTORING
   Step 1: cm callers <function>
   → Understand impact (who depends on this?)
   
   Step 2: cm callees <function>
   → What does it depend on? (what breaks if we change this?)
   
   Step 3: cm tests <function>
   → Run tests (verify nothing breaks)
   
   Step 4: cm since main --breaking
   → (After refactor) Did we break anything vs main?

4. UNDERSTANDING AN API
   Step 1: cm entrypoints .
   → What's exported? (what's the public surface?)
   
   Step 2: cm implements <interface>
   → Find all implementations (how many ways is this used?)
   
   Step 3: cm schema <DataClass>
   → See field structure (what does the data look like?)

5. VALIDATING CODE HEALTH
   Step 1: cm untested .
   → Find uncovered symbols (what's not tested?)
   
   Step 2: cm since <last_release> --breaking
   → Did we break anything? (breaking changes since release?)
   
   Step 3: cm since <last_release>
   → Full changelog (what changed?)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COMMANDS (organized by task)

[DISCOVERY - Start here]
  stats        → Project size and composition (functions, classes, imports)
  map          → File listing with symbol counts (3 detail levels)
  query        → Find symbols by name (main search tool)
  inspect      → List all symbols in one file
  deps         → Track imports and usage

[CALL GRAPH - Understand code flow]
  callers      → WHO calls this function? (reverse dependencies)
  callees      → What DOES this function call? (forward dependencies)
  trace        → CALL PATH from A → B (shortest route)
  entrypoints  → Public APIs with no internal callers (dead code?)
  tests        → Which tests call this symbol?
  test-deps    → What production code does a test touch?

[GIT HISTORY - Blame and timeline]
  diff         → Symbol-level changes vs a commit (what changed?)
  since        → Breaking changes since commit (what broke?)
  blame        → Who last touched this symbol? (when, commit, author)
  history      → Full evolution of a symbol (all commits touching it)

[TYPE ANALYSIS - Understand data flow]
  types        → Parameter types and return type (where are they defined?)
  implements   → Find all implementations of an interface
  schema       → Field structure (structs, classes, dataclasses)

[SNAPSHOTS - Compare over time]
  snapshot     → Save current state (named checkpoint)
  compare      → Diff current vs saved snapshot (what changed?)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

KEY FACTS

OUTPUT FORMATS:
  --format default  → Markdown (documentation, readable)
  --format human    → Tables (terminal viewing, pretty)
  --format ai       → Compact (LLM context, token-efficient) ← RECOMMENDED

PERFORMANCE:
  Small repos (< 100 files)    → < 20ms instant
  Medium repos (100-1000)      → Cached, ~0.5s load
  Large repos (1000+)          → Fast mode auto-enabled (10-100x speedup)
  Incremental rebuilds         → 45-55x faster than full reindex

CACHING:
  Auto-enabled on projects ≥ 300ms to parse
  Small projects never create cache (no .codemapper/ clutter)
  Subsequent runs load from cache (~0.5s)
  File changes auto-detected (you don't manage cache)
  Flags: --no-cache (skip), --rebuild-cache (force rebuild)

SEARCH MODES:
  Exact   → cm query MyClass           (case-sensitive, precise)
  Fuzzy   → cm query myclass          (DEFAULT: case-insensitive, flexible)
  Exact   → cm query myclass --exact  (strict matching)

LANGUAGES SUPPORTED:
  ✓ Python       → Functions, classes, methods, imports
  ✓ JavaScript   → Functions, classes, methods, imports
  ✓ TypeScript   → Functions, classes, methods, interfaces, types, enums
  ✓ Rust         → Functions, structs, impl blocks, traits, enums
  ✓ Java         → Classes, interfaces, methods, enums, javadoc
  ✓ Go           → Functions, structs, methods, interfaces
  ✓ C            → Functions, structs, includes
  ✓ Markdown     → Headings, code blocks

GIT REQUIREMENTS:
  diff      → Must be in a git repo
  since     → Must be in a git repo
  blame     → Must be in a git repo
  history   → Must be in a git repo
  (Other commands work anywhere)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COMMON FLAGS

--exact              → Strict matching (default is fuzzy)
--format <format>    → Output style: default (markdown), human (tables), ai (compact)
--show-body          → Include actual code (not just signatures)
--exports-only       → Public symbols only (functions with export, pub, etc.)
--full               → Include anonymous/lambda functions (normally hidden)
--context minimal    → Signatures only (default, fast)
--context full       → Include docstrings and metadata
--no-cache           → Skip cache, always reindex (troubleshooting)
--rebuild-cache      → Force cache rebuild
--extensions py,rs   → Comma-separated file types to include

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TROUBLESHOOTING

NO SYMBOLS FOUND?
  ✓ Fuzzy matching by default (matches more)
  ✓ Check --extensions py,js,ts (default: py,js,ts,jsx,tsx,rs,java,go,c,h,md)
  ✓ Verify file encoding is UTF-8
  ✓ Run: cm stats . (to see what's indexed)

SLOW QUERIES?
  ✓ Large repo (1000+ files)? Fast mode auto-enables (use --fast explicitly)
  ✓ First run builds cache (~10s), cache hits ~0.5s after
  ✓ Try --no-cache if cache is stale (rare)

GIT COMMANDS FAIL?
  ✓ Must be in a git repository (diff, since, blame, history need git)
  ✓ Commit must exist (HEAD~1, abc123, main, v1.0 all work)
  ✓ File must have git history (blame, history)

OUTPUT TOO VERBOSE?
  ✓ Use --format ai (most compact, LLM-optimized)
  ✓ Use --format human (pretty tables for terminal)
  ✓ Use --context minimal (signatures only)

NO TEST COVERAGE?
  ✓ Run: cm untested .
  ✓ Test detection by file pattern (_test.rs, test_*.py, *.test.js, etc.)
  ✓ Test detection by naming convention (test*, Test*, #[test], @Test, etc.)

EXAMPLES:
  # Get the lay of the land
  cm stats .                           # Project overview
  cm map . --level 2 --format ai       # File structure
  
  # Find and explore
  cm query authenticate                # Search (fuzzy by default)
  cm inspect ./src/auth.py             # Deep dive
  cm query Parser --show-body          # See implementation
  
  # Understand flow
  cm callers process_payment           # Who calls it?
  cm callees process_payment           # What does it call?
  cm trace main process_payment        # Call path
  
  # Before refactoring
  cm callers my_function               # Impact radius
  cm tests my_function                 # Verify coverage exists
  
  # Git analysis
  cm diff main                         # Changes vs main
  cm since v1.0 --breaking             # Breaking changes since v1.0
  cm blame authenticate ./auth.py      # Who last touched it?
  
  # Type analysis
  cm types process_payment             # What types flow through?
  cm schema Order                      # Field structure
  cm implements Iterator               # Find all implementations
  
  # Health check
  cm untested .                        # What's not tested?
  cm entrypoints .                     # Public API surface

For detailed help on any command: cm <command> --help


Usage: cm [OPTIONS] <COMMAND>

Commands:
  stats        Display statistics: file counts, symbol breakdown, and parse performance
  map          Generate a map showing project organization at different detail levels (1-3)
  query        Search for functions, classes, and methods across your codebase
  inspect      Analyze one file and list all functions, classes, and methods it contains
  deps         Analyze import relationships and symbol usage across the codebase
  index        Test that files can be indexed correctly (reports file count and timing)
  diff         Show symbol-level changes between current code and a git commit
  callers      Find all places where a function/method is called
  callees      Find all functions/methods that a symbol calls
  tests        Find test functions that call a given symbol
  untested     Find functions and methods that are not called by any test
  since        Show breaking API changes since a git commit (removed symbols, signature changes)
  entrypoints  Find entrypoints: exported symbols that are not called internally
  trace        Show the shortest call path from symbol A to symbol B
  impact       Quick breakage report for a symbol (definition + callers + tests)
  test-deps    List production (non-test) symbols called by a test file
  blame        Show who last modified a symbol and when
  history      Show the evolution of a symbol across git history
  implements   Find all classes/structs that implement a given interface or trait
  types        Analyze types used in a symbol's signature and locate their definitions
  schema       Display field schema for data structures (structs, classes, dataclasses, etc.)
  snapshot     Save a snapshot of current codebase symbols for later comparison
  compare      Show symbol-level changes between current code and a saved snapshot
  help         Print this message or the help of the given subcommand(s)

Options:
  -f, --format <FORMAT>  Output format: 'default' (markdown), 'human' (tables), 'ai' (token-efficient) [default: default]
  -h, --help             Print help concise (commands + key flags, ~30-60 lines) and keep current long narrative for CodeMapper (cm) - Code Analysis at LLM Speed

Analyze codebases instantly by mapping symbols (functions, classes, methods)
using tree-sitter AST parsing. Everything runs in-memory, no databases.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TYPICAL WORKFLOWS

1. EXPLORING UNKNOWN CODE
   Step 1: cm stats .
   → Size and composition (how big? what languages?)
   
   Step 2: cm map . --level 2 --format ai
   → File structure (where's the logic?)
   
   Step 3: cm query <symbol>
   → Find code (where exactly?)
   
   Step 4: cm inspect ./path/to/file
   → Deep dive (what's in this module?)

2. FINDING A BUG (you know the symptom, need the source)
   Step 1: cm query <suspected_function> --show-body
   → See the implementation
   
   Step 2: cm callers <function>
   → Who calls this? (Is it called from where the bug manifests?)
   
   Step 3: cm trace <entry_point> <suspected_function>
   → Trace the call path (how does the bug get triggered?)
   
   Step 4: cm tests <function>
   → Find tests (are there existing tests for this?)

3. BEFORE REFACTORING
   Step 1: cm callers <function>
   → Understand impact (who depends on this?)
   
   Step 2: cm callees <function>
   → What does it depend on? (what breaks if we change this?)
   
   Step 3: cm tests <function>
   → Run tests (verify nothing breaks)
   
   Step 4: cm since main --breaking
   → (After refactor) Did we break anything vs main?

4. UNDERSTANDING AN API
   Step 1: cm entrypoints .
   → What's exported? (what's the public surface?)
   
   Step 2: cm implements <interface>
   → Find all implementations (how many ways is this used?)
   
   Step 3: cm schema <DataClass>
   → See field structure (what does the data look like?)

5. VALIDATING CODE HEALTH
   Step 1: cm untested .
   → Find uncovered symbols (what's not tested?)
   
   Step 2: cm since <last_release> --breaking
   → Did we break anything? (breaking changes since release?)
   
   Step 3: cm since <last_release>
   → Full changelog (what changed?)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COMMANDS (organized by task)

[DISCOVERY - Start here]
  stats        → Project size and composition (functions, classes, imports)
  map          → File listing with symbol counts (3 detail levels)
  query        → Find symbols by name (main search tool)
  inspect      → List all symbols in one file
  deps         → Track imports and usage

[CALL GRAPH - Understand code flow]
  callers      → WHO calls this function? (reverse dependencies)
  callees      → What DOES this function call? (forward dependencies)
  trace        → CALL PATH from A → B (shortest route)
  entrypoints  → Public APIs with no internal callers (dead code?)
  tests        → Which tests call this symbol?
  test-deps    → What production code does a test touch?

[GIT HISTORY - Blame and timeline]
  diff         → Symbol-level changes vs a commit (what changed?)
  since        → Breaking changes since commit (what broke?)
  blame        → Who last touched this symbol? (when, commit, author)
  history      → Full evolution of a symbol (all commits touching it)

[TYPE ANALYSIS - Understand data flow]
  types        → Parameter types and return type (where are they defined?)
  implements   → Find all implementations of an interface
  schema       → Field structure (structs, classes, dataclasses)

[SNAPSHOTS - Compare over time]
  snapshot     → Save current state (named checkpoint)
  compare      → Diff current vs saved snapshot (what changed?)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

KEY FACTS

OUTPUT FORMATS:
  --format default  → Markdown (documentation, readable)
  --format human    → Tables (terminal viewing, pretty)
  --format ai       → Compact (LLM context, token-efficient) ← RECOMMENDED

PERFORMANCE:
  Small repos (< 100 files)    → < 20ms instant
  Medium repos (100-1000)      → Cached, ~0.5s load
  Large repos (1000+)          → Fast mode auto-enabled (10-100x speedup)
  Incremental rebuilds         → 45-55x faster than full reindex

CACHING:
  Auto-enabled on projects ≥ 300ms to parse
  Small projects never create cache (no .codemapper/ clutter)
  Subsequent runs load from cache (~0.5s)
  File changes auto-detected (you don't manage cache)
  Flags: --no-cache (skip), --rebuild-cache (force rebuild)

SEARCH MODES:
  Exact   → cm query MyClass           (case-sensitive, precise)
  Fuzzy   → cm query myclass          (DEFAULT: case-insensitive, flexible)
  Exact   → cm query myclass --exact  (strict matching)

LANGUAGES SUPPORTED:
  ✓ Python       → Functions, classes, methods, imports
  ✓ JavaScript   → Functions, classes, methods, imports
  ✓ TypeScript   → Functions, classes, methods, interfaces, types, enums
  ✓ Rust         → Functions, structs, impl blocks, traits, enums
  ✓ Java         → Classes, interfaces, methods, enums, javadoc
  ✓ Go           → Functions, structs, methods, interfaces
  ✓ C            → Functions, structs, includes
  ✓ Markdown     → Headings, code blocks

GIT REQUIREMENTS:
  diff      → Must be in a git repo
  since     → Must be in a git repo
  blame     → Must be in a git repo
  history   → Must be in a git repo
  (Other commands work anywhere)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COMMON FLAGS

--exact              → Strict matching (default is fuzzy)
--format <format>    → Output style: default (markdown), human (tables), ai (compact)
--show-body          → Include actual code (not just signatures)
--exports-only       → Public symbols only (functions with export, pub, etc.)
--full               → Include anonymous/lambda functions (normally hidden)
--context minimal    → Signatures only (default, fast)
--context full       → Include docstrings and metadata
--no-cache           → Skip cache, always reindex (troubleshooting)
--rebuild-cache      → Force cache rebuild
--extensions py,rs   → Comma-separated file types to include

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TROUBLESHOOTING

NO SYMBOLS FOUND?
  ✓ Fuzzy matching by default (matches more)
  ✓ Check --extensions py,js,ts (default: py,js,ts,jsx,tsx,rs,java,go,c,h,md)
  ✓ Verify file encoding is UTF-8
  ✓ Run: cm stats . (to see what's indexed)

SLOW QUERIES?
  ✓ Large repo (1000+ files)? Fast mode auto-enables (use --fast explicitly)
  ✓ First run builds cache (~10s), cache hits ~0.5s after
  ✓ Try --no-cache if cache is stale (rare)

GIT COMMANDS FAIL?
  ✓ Must be in a git repository (diff, since, blame, history need git)
  ✓ Commit must exist (HEAD~1, abc123, main, v1.0 all work)
  ✓ File must have git history (blame, history)

OUTPUT TOO VERBOSE?
  ✓ Use --format ai (most compact, LLM-optimized)
  ✓ Use --format human (pretty tables for terminal)
  ✓ Use --context minimal (signatures only)

NO TEST COVERAGE?
  ✓ Run: cm untested .
  ✓ Test detection by file pattern (_test.rs, test_*.py, *.test.js, etc.)
  ✓ Test detection by naming convention (test*, Test*, #[test], @Test, etc.)

EXAMPLES:
  # Get the lay of the land
  cm stats .                           # Project overview
  cm map . --level 2 --format ai       # File structure
  
  # Find and explore
  cm query authenticate                # Search (fuzzy by default)
  cm inspect ./src/auth.py             # Deep dive
  cm query Parser --show-body          # See implementation
  
  # Understand flow
  cm callers process_payment           # Who calls it?
  cm callees process_payment           # What does it call?
  cm trace main process_payment        # Call path
  
  # Before refactoring
  cm callers my_function               # Impact radius
  cm tests my_function                 # Verify coverage exists
  
  # Git analysis
  cm diff main                         # Changes vs main
  cm since v1.0 --breaking             # Breaking changes since v1.0
  cm blame authenticate ./auth.py      # Who last touched it?
  
  # Type analysis
  cm types process_payment             # What types flow through?
  cm schema Order                      # Field structure
  cm implements Iterator               # Find all implementations
  
  # Health check
  cm untested .                        # What's not tested?
  cm entrypoints .                     # Public API surface

For detailed help on any command: cm <command> --help


Usage: cm [OPTIONS] <COMMAND>

Commands:
  stats        Display statistics: file counts, symbol breakdown, and parse performance
  map          Generate a map showing project organization at different detail levels (1-3)
  query        Search for functions, classes, and methods across your codebase
  inspect      Analyze one file and list all functions, classes, and methods it contains
  deps         Analyze import relationships and symbol usage across the codebase
  index        Test that files can be indexed correctly (reports file count and timing)
  diff         Show symbol-level changes between current code and a git commit
  callers      Find all places where a function/method is called
  callees      Find all functions/methods that a symbol calls
  tests        Find test functions that call a given symbol
  untested     Find functions and methods that are not called by any test
  since        Show breaking API changes since a git commit (removed symbols, signature changes)
  entrypoints  Find entrypoints: exported symbols that are not called internally
  trace        Show the shortest call path from symbol A to symbol B
  impact       Quick breakage report for a symbol (definition + callers + tests)
  test-deps    List production (non-test) symbols called by a test file
  blame        Show who last modified a symbol and when
  history      Show the evolution of a symbol across git history
  implements   Find all classes/structs that implement a given interface or trait
  types        Analyze types used in a symbol's signature and locate their definitions
  schema       Display field schema for data structures (structs, classes, dataclasses, etc.)
  snapshot     Save a snapshot of current codebase symbols for later comparison
  compare      Show symbol-level changes between current code and a saved snapshot
  help         Print this message or the help of the given subcommand(s)

Options:
  -f, --format <FORMAT>  Output format: 'default' (markdown), 'human' (tables), 'ai' (token-efficient) [default: default]
  -h, --help             Print help; reduce repetition and keep examples minimal",closed,1,Pi,Pi,Pi,2026-01-11T03:08:46.273Z,2026-01-11T03:11:06.550Z,,m-b6a5
m-5daf,"dx: tighten help text (reduce repetition, clearer defaults)",trim repeated sections across subcommands; ensure each command has 1 ai example; clarify impact default top-10 + --all; mention callers ambiguity,closed,2,Pi,Pi,Pi,2026-01-11T03:08:51.404Z,2026-01-11T03:11:06.550Z,,m-b6a5
m-6ce0,dx: add disambiguation flags (impact/callers/query),add optional flags like --pick <n> and/or --prefer-file <path> to select among fuzzy matches without extra steps,open,1,Pi,Pi,,2026-01-11T03:08:56.228Z,2026-01-11T03:11:15.513Z,,m-b6a5
m-b6a5,dx pass: help system overhaul,"umbrella: implement short help (-h) vs long help (--help), tighten text, and (if time) add disambiguation flags",closed,1,Pi,Pi,Pi,2026-01-11T03:09:01.568Z,2026-01-11T03:11:06.550Z,m-7c2a|m-5daf|m-6ce0,
m-8f1e,p1: rust index enum variants (for clap-style command enums),implemented: rust parser now indexes enum variants as symbols named EnumName::Variant (SymbolType::Enum) so clap-style enums are searchable. repro: cm query Command::Implements --exact works on a sample. note: bare Implements still won’t match unless we also index unqualified names.,closed,1,Pi,Pi,Pi,2026-01-11T03:22:26.312Z,2026-01-11T03:24:51.322Z,m-7fa8|m-c7bb,
m-12c4,p1: callers accept qualified names (Type::method / Type.method),"implemented partially: callgraph matching now normalizes qualified inputs by stripping qualifiers (Type:: / Type.). remaining: cmd_callers/cmd_callees still validate symbol existence using raw name, so ✗ Symbol 'Type::method' not found in codebase says 'symbol not found' even though matching could work; normalize before lookup.",closed,1,Pi,Pi,Pi,2026-01-11T03:23:02.103Z,2026-01-11T03:28:31.210Z,m-c7bb,m-f597
m-f597,p1: normalize qualified names in cmd_callers/cmd_callees/cmd_tests/cmd_impact lookup,finish m-12c4: accept inputs like Type::method by normalizing before symbol lookup and reporting; use same normalization helper as callgraph.,closed,1,Pi,Pi,Pi,2026-01-11T03:26:00.312Z,2026-01-11T03:28:31.210Z,m-12c4,
